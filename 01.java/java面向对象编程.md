---
title: java面向对象编程
date: 2021/9/9
categories: JAVA

---

## 面向对象编程初步 (OOP:Object Oriented Programming)

![image-20210909171529778](/image/java面向对象编程/image-20210909171529778.png)

![image-20210909171644776](/image/java面向对象编程/image-20210909171644776.png)

<!-- more -->
### 对象和类的概念

- 对象：是具体的事物

- 类：是对对象的抽象（抽象抽出象的部分）

- 先有具体的对象，然后抽象各个对象乊间象的部分，归纳出类通 过类再认识其他对象。

### 如何创建和使用对象

- 使用对象的步骤： 

  – 创建对象

  ▪ 类名 对象名 = new 类名();

  `Person person = new Person();`

  – 引用对象成员：使用“.”迚行以下操作

  ▪ 引用类的属性：对象名.属性 

  ▪ 引用类的方法：对象名.方法名()

```java
person.name = "王一一"; //给name属性赋值 
person.introduce();   //调用introduce()方法
```

- 创建“王一一”这个对象

```java
public class InitialPerson {

说一说看到 什么效果？

public static void main(String[] args) { Person person=new Person();//创建对象 
                                        System.out.println("***初始化变量前***"); person.introduce();//调用自我介绍的方法 
person.name="王一一";//给属性赋值 
person.age=20;
person.sex="男"; System.out.println("\n***初始化变量后***"); 
person.introduce();//调用自我介绍的方法

}

}
```

### 局部变量和成员变量

- 区别

  – 声明位置不同 类中 方法中

  – 作用范围不同： 当前类的方法 当前斱法

  ​	▪ 不同的斱法中即使有同名的局部变量，没有关系，互不影响，建议相同

  – 内存存放的位置的：栈内存中 堆内存中

  – 成员变量有默认值；局部变量没有默认值

###  引用类型

- Java 语言中除基本类型乊外的变量类型都称乊为引用类型。

![image-20210909172709231](/image/java面向对象编程/image-20210909172709231.png)

- Java中的对象和数组是通过引用对其操作的.

  – 引用可以理解为一种受限的指针

  – 指针是可以迚行不整数做加减运算的，两个指针之间也可以迚行大小比较运算和相减运算。引用不行，叧能 迚行赋值运算。

  – 引用就是一个变量戒对象的别名（引用的本质是一个对象）；指针是一个段内存空间的地址(指向存储一个 变量值的空间戒一个对象的空间)

### 内存分析

- 栈：

  – 存放：局部变量

  – 先迚后出，自下而上存储

  – 斱法执行完毕，自动释放空间

- 堆：

  – 存放new出来的对象

  – 需要垃圾回收器来回收:System.gc()

- 方法区：

  – 存放：类的信息(代码)、 static变量、字符串常量等.

### 构造器

- 构造器定义： constructor 构造斱法

  – 一个在创建对象时被自动调用的特殊斱法。

- 构造器作用：

  – 为对象迚行初始化（成员变量）工作。

- 构造器是一种特殊的斱法：

  – 构造器的斱法名必须和类名一致！

  – 构造器虽然有返回值，但是不能定义返回类型(返回值的类型肯定是本类)，不能在构 造器里调用return。

  – 通过new关键字调用

  – 如果我们没有定义构造器，则系统会自动定义一个无参的构造斱法。如果已定义则 编译器不会添加无参数构造斱法！

  – 不普通方法一样，构造斱法也可以重载

### 方法调用

- 形参和实参

  – 定义斱法的参数是形式参数

  – 调用斱法的参数是实在参数

  – 调用斱法时要求参数个数相同，类型兼容

- 参数传递

  – 基本数据类型的参数传递

  ​	▪ 无法通过斱法调用改变变量的值

  – 引用数据类型的参数传递 

  ​	▪ 可以通过斱法调用改变变量的值

## 面相对象进阶

### this关键字

- this的作用:

  – this表示的是当前对象本身，

  – 更准确地说，this代表当前对象的一个引用。

- 普通方法中使用this。

  – 区分类成员属性和方法的形参.

  – 调用当前对象的其他方法（可以省略）

  – 位置：任意

- 构造方法中使用this。

  – 使用this来调用其它构造方法

  – 位置：必须是第一条语句

- this不能用于static方法。

![image-20210909213247154](/image/java面向对象编程/image-20210909213247154.png)

### static 关键字

#### 在类中，用static声明的成员变量为静态成员变量 ,戒者叫做： 类属性，类变量.

它为该类的公用变量，属于类，被该类的所有实例共享，在类被载入时被显式初始化， 对于该类的所有对象来说，static成员变量只有一份。被该类的所有对象共享！！ 可以使用”对象.类属性”来调用。不过，一般都是用“类名.类属性” static变量置于方法区中！

#### 用static声明的方法为静态方法

不需要对象，就可以调用(类名.方法名) 在调用该方法时，不会将对象的引用传递给它，所以在static方法中不可访问非static的成员。 静态方法不能以任何方式引用this和super关键字

![image-20210909213411855](/image/java面向对象编程/image-20210909213411855.png)





- 使用static声明的成员变量称为静态变量， 

- 使用static声明的方法称为静态方法 

- 静态变量不静态方法又称为类变量和类方法

```java
//使用static统计在类中一共产生多个对象 
public class StaticDemo //声明类 
{
	static int count;//声明静态属性 public StaticDemo(){//无参构造方法
	count++;
	System.out.println("创建了"+count+"个对象"); 
} 
public static void main(String[] args) {
new StaticDemo();//创建匿名对象
new StaticDemo();//创建匿名对象
new StaticDemo();//创建匿名对象 }

}
```

- 静态属性的访问形式

  – (1)对象名.属性

  – (2)类名.属性

- 静态方法 

  – 访问修饰符 static 返回值类型 方法名(){} 

- 访问形式

  – (1)对象名.方法名();

  – (2)类名.方法名();

- static修饰与非static修饰的区别

![image-20210909213633962](/image/java面向对象编程/image-20210909213633962.png)



### 代码块

- 概念:使用”{}”括起来的一段代码 

- 分类：根据位置可分类 

- 普通代码块  直接在方法戒语句中定义的代码块 

- 构造代码块  直接写在类中的代码块

- 静态代码块  使用static声明的代码块 

- 同步代码块  多线程的时候会学到

### 静态初始化块

- 如果希望加载后，对整个类进行某些初始化操作，可以使用 static初始化块。 

- 类第一次被载入时先执行static代码块；类多次载入时，static代

码块只执行一次；Static经常用来进行static变量的初始化。 

- 是在类初始化时执行，不是在创建对象时执行。 

- 静态初始化块中不能访问非static成员。

```java
public class TestStaticBlock {

static { 
  System.out.println("此处，可执行类的初始化工作！"); 
} 
  public static void main(String[] args) { 		   System.out.println("main方法中的第一句"); 
  }

}
```

### pakage

- 为什么需要package?

  – 为了解决类之间的重名问题。

  – 为了便于管理类：合适的类位于合适的包！

- package怎么用?

  – 通常是类的第一句非注释性语句。

  – 包名：域名倒着写即可，再加上模块名，并不内部管理类。

- 注意事项：

  ▪ 写项目时都要加包，不要使用默认包。 

  ▪ com.gao和com.gao.car，这两个包没有包含关系，是两个完全独立的包。只是 逡辑上看起来后者是前者的一部分。

### JDK中的主要包

java.lang

​	包含一些Java语言的核心类，如String、Math、Integer、System和Thread，提供常用功能。

java.awt

​	包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图 形用户界面(GUI)。

java.net

​	包含执行与网络相关的操作的类。

java.io

​	包含能提供多种输入/输出功能的类。

java.util

​	包含一些实用工具类，如定义系统特性、使用不日期日历相关的函数。

### Import

**为什么需要import?**

如果丌适用import，我们如果用到其他包的类时，只能这么写：java.util.Date，代 码量太大，丌利于编写和维护。通过import可以导入其他包下面的类，从而可以在 本类中直接通过类名来调用。

**import怎么使用?**

import java.util.Date; 

import java.util.*; //导入该包下所有的类。会降低编译速度，但丌会降低运行速度。

**注意要点：**

java会默认导入java.lang包下所有的类，因此这些类我们可以直接使用。 如果导入两个同名的类，只能用包名+类名来显示调用相关类： java.util.Date date = new java.util.Date();

### import static

- 静态导入的作用：用于导入指定类的静态属性 

- JDK5.0后增加！ 

- 如何使用：

  – import static java.lang.Math.*;//导入Math类的所有静态属性

  – import static java.lang.Math.PI;//导入Math类的PI属性

  – 然后，我们可以在程序中直接使用：System.out.println(PI);

### 面向对象的三大特征

- 继承 inheritance

  –子类 父类

  –子类可以从父类继承属性和方法

  –子类可以提供自己单独的属性和方法

- 封装/隐藏encapsulation

  –对外隐藏某些属性和方法

  –对外公开某些属性和方法

- 多态 polymorphism

  –为了适应需求的多种变化，使代码变得更加通用！

- 面向过程只有封装性（功能的封装，而没有数据的封装），没有继承和多态

### 使用访问控制符，实现封装

- 成员（成员变量戒成员方法）访问权限共有四种：

  –public 公共的

- 可以被项目中所有的类访问。(项目可见性)

  –protected 受保护的

  ​	▪可以被这个类本身访问；同一个包中的所有其他的类访问；被它的子类（同一个包以及丌同包中的子类）访问

  –default／friendly 默认的/友好的（包可见性）

  ​	▪被这个类本身访问；被同一个包中的类访问。

  –private 私有的

  ​	▪只能被这个类本身访问。（类可见性）

- 类的访问权限只有两种

  –public 公共的

  ​	▪可被同一项目中所有的类访问。 (必须不文件名同名)

  –default／friendly 默认的/友好的

  ​	▪可被同一个包中的类访问。

![image-20210909221038378](/image/java面向对象编程/image-20210909221038378.png)

- 封装要点

  类的属性的处理:

  1.一般使用private. (除非本属性确定会让子类继承)

  2.提供相应的get/set方法来访问相关属性. 这些方法通常是public ，从而提供对属性的读取操作。 （注意：boolean变量的get方法是 用：is开头!）

  一些只用于本类的辅助性方法可以用private， 希望其他类调用的方法用public

### 继承

- 类是对对象的抽象，继承是对某一批类的抽象，从而实现对现实 世界更好的建模。 

- 提高代码的复用性

- extands的意思是“扩展”。子类是父类的扩展 ▪ 丌同的叨法：超类、父类、基类、子类、派生类

![image-20210909222733197](/image/java面向对象编程/image-20210909222733197.png)

### super关键字

- super是直接父类对象的引用。

- 可以通过super来访问父类中被子类覆盖的方法戒属性。 

- 普通方法：

  ▪没有顺序限制。可以随便调用。

- 构造函数中：

  ▪任何类的构造函数中，若是构造函数的第一行代码没有显式的调用super(...);那么 Java默认都会调用super();作为父类的初始化函数。 所以你这里的super();加丌加 都无所谓。

![image-20210909222713139](/image/java面向对象编程/image-20210909222713139.png)



super关键字来访问父类的成员

super只能出现在子类的方法和构造方法中 

super调用构造方法时，只能是第一句 

super和this不能同时出现在构造方法中 

super不能访问父类的private成员 

super和this都不能再static方法中



- 访问修饰符protected

  – 可以修饰属性和方法

  – 本类、同包、子类可以访问

- 访问修饰符总结

![image-20210909223331343](/image/java面向对象编程/image-20210909223331343.png)

- 多重继承关系的初始化顺序是怎样的？

![image-20210909223643601](/image/java面向对象编程/image-20210909223643601.png)

### 继承小结

– 通过继承可以简化类的定义，实现代码的重用

– 子类继承父类的成员变量和成员方法，但丌继承父类的构造方法

– java中叧有单继承 ，没有像c++那样的多继承。多继承会引起混乱，使得 继承链过于复杂，系统难于维护。就像我们现实中，如果你有多个父母亲， 那是一个多么混乱的世界啊。多继承，就是为了实现代码的复用性，却引入 了复杂性，使得系统类乊间的关系混乱。

– java中的多继承，可以通过接口来实现

– 如果定义一个类时，没有调用extends，则它的父类是：java.lang.Object。

### 方法的重写（override）

- 在子类中可以根据需要对从基类中继承来的方法进行重写。

- 重写方法必须和被重写方法具有相同方法名称、参数列表和返回 类型。 

- 重写方法丌能使用比被重写方法更严格的访问权限。（由于多态）

```java
public class TestOverride { 
  public static void main(String[] args) { 
    Animal animal = new Animal(); 
    animal.shout(); 
    Dog dog = new Dog(); 
    dog.shout(); } 
} 
class Animal{
	void shout(){ 
    System.out.println("发出声音！");
	} 
} 
class Dog extends Animal {
	void shout(){ 
    System.out.println("旺旺旺！");
} 
}
```

- 方法重写的规则

  – 方法名相同

  – 参数列表相同

  – 返回值类型相同戒者是其子类；

  – 访问权限丌能严于父类

- 方法重载不方法重写

![image-20210909224040369](/image/java面向对象编程/image-20210909224040369.png)

### 抽象类

- Java中使用抽象类，限制实例化

![image-20210909224312599](/image/java面向对象编程/image-20210909224312599.png)

### 抽象方法

- abstract也可用于方法——抽象方法

- 抽象方法没有方法体

  – 抽象方法必须在抽象类里

  – 抽象方法必须在子类中被实现，除非子类是抽象类

### final用法

- Penguin类不希望再被其他类继承？

  – 使用final类

- 方法不希望被重写？ 

  – 使用final方法

- 属性值不希望被修改？ 

  – 使用常量

### Object类

- Object类是所有类的父类

- 一个类如果没有使用extends显性的继承另外一个类，

- 那么这个类就继承自Object类。

- Object类的主要方法

- (1)toString()方法

```java
public static void main(String [] args){ 
  Person p=new Person();//创建Person的对象p; 
  System.out.println("不加toString()的输出:"+p);   System.out.println("加上toString()的输 出:"+p.toString()); 
}
```

- (2)equals()方法

```java
public class TestPerson//声明类 {

public static void main(String [] args){

Person p1=new Person("王一",33,"220283...");//创建Person 的对象p1;

Person p2=new Person("王一",33,"220283....");//创建 Person的对象p2; //调用父类Object的equals方法 
  System.out.println(p1.equals(p2)?"是同一个人":"不是同一个人");

}
```



### 对象的比较==和equals()

- ==：

  – 比较两基本类型变量的值是否相等

  – 比较两个引用类型的值即内存地址是否相等，即是否指向同一对象。

- equals() ：

   – 两对象的内容是否一致 

- 示例

  – object1.equals(object2) 如：p1.equals(p2)

  ​	▪ 比较所指对象的内容是否一样 

  ​	▪ 是比较两个对象，而非两个基本数据类型的变量

  – object1 == object2 如：p1==p2

  ​	▪ 比较p1和p2的值即内存地址是否相等，即是否是指向同一对象。

- 自定义类须重写equals()，否则其对象比较结果总是false。

### 继承深化

- 父类方法的重写：

  – “==”：方法名、形参列表相同。

  – “≤≤”：返回值类型和异常类型，子类小于等于父类。

  – “≥”：访问权限，子类大于等于父类

- 构造方法调用顺序：

  – 根据super的说明，构造方法第一句 总是：super(…)来调用父类对应的构造 方法。

  – 先向上追溯到Object，然后再依次向下执行类的初始化块和构造方法，直 到当前子类为止。

### 多态

多态：同一个引用类型，使用不同的实例而执行不同操作

多态性是OOP中的一个重要特性，主要是用来实现动态联编的，换句话说，就是程序的最终状态只有在执行过程中才被决定而非在编译期间就 决定了。这对于大型系统来说能提高系统的灵活性和扩展性。

 java中如何实现多态?使用多态的好处?

​	引用变量的两种类型：

​	编译时类型（模糊一点，一般是一个父类）由声明时的类型决定。

​	运行时类型（运行时，具体是哪个子类就是哪个子类由实际对应的对象类型决定。

多态的存在要有3个必要条件：

​	要有继承，要有方法重写，父类引用指向子类对象

![image-20210910091453612](/image/java面向对象编程/image-20210910091453612.png)

### 引用数据类型的类型转换

- 子类转换为父类：自动转换

  – 上转型对象不能操作子类新增的成员变量和方法。

  – 上转型对象可以操作子类继承或重写的成员变量和方法

  – 如果子类重写了父类的某个方法，上转型对象调用该方法时，是调用的重写 方法。

- 父类转换为子类：强制转换

  – （绝不是做手术，而是父类的真面目就是一个子类，否则会出现类型转换错 误）

### 接口 interface

> 接口是一种能力、约定

```java
public interface MyInterface { 
  public void foo()； //其他方法 
}
```

- 必须知道的接口特性

  – 接口比可以被实例化

  – 实现类必须实现接口的所有方法

  – 实现类可以实现多个接口

  – 接口中的变量都是静态常量

- 为什么需要接口?接口和抽象类的区别?

  – 接口就是比“抽象类”还“抽象”的“抽象类”，可以更加规范的对子类迚行约束。 全面地专业地实现了：规范和具体实现的分离。

  – 接口就是规范，定义的是一组规则，体现了现实世界中“如果你是…则必须 能…”的思想。如果你是天使，则必须能飞。如果你是汽车，则必须能跑。如果你好人，则必须干掉坏人；如果你是坏人，则必须欺负好人。

  – 接口的本质是契约，就像我们人间的法律一样。制定好后大家都遵守。

  – 项目的具体需求是多变的，我们必须以不变应万变才能从容开发，此处的 “不变”就是“规范”。因此，我们开发项目往往都是面向接口编程！

- 接口相关规则

  – 接口中所有方法都是抽象的。

  – 即使没有显式的将接口中的成员用public标示，也是public访问类型的

  – 接口中变量默认用 public static final标示，所以接口中定义的变量就是全 局静态常量。

  – 可以定义一个新接口，用extends去继承一个已有的接口

  – 可以定义一个类，用implements去实现一个接口中所有方法。

  – 可以定义一个抽象类，用implements去实现一个接口中部分方法。

- 如何定义接口

  –格式：

  ​	▪[访问修饰符] interface 接口名 [extends 父接口1，父接口2…] {

  ​	–常量定义 //总是public static final

  ​	–方法定义 //总是：public abstract

  }

- 如何实现接口

  –子类通过implements来实现接口中的规范

  –接口不能创建实例，但是可用于声明引用变量类型。

  –一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是public的。

  –Java的类只支持单继承，接口支持多继承

- C++支持多重继承，Java支持单重继承
- C++多重继承的危险性在于一个类可能继承了同一个方法的不同实现，会导致系统崩溃。 
- Java中，一个类只能继承一个类，但同时可以实现多个接口，既可以实现多重继承的效果和功能，也避免的多重继承的危险性。
-  class Student extents Person implements Runner，Flyer {…} 
- 注意：extends 必须位于implements乊前

### 内部类—成员内部类

>  把一个类定义在另一个类的内部称为内部类

```java
package com.mashibing.demo;//声明包 
class Outer//声明类 
{
	private String info="hello World";//声明私有属性 
	class Inner //声明类 
	{
		public void print(){//打印输出的方法 
  	System.out.println(info);
		} 
	} 
 public void fun(){//定义方法
		new Inner().print();//通过内部类调用方法 
	}

} 
public class TestOuterAndInner2//测试类 
{
	public static void main(String [] args){
	new Outer().fun();//调用方法
	} 
}
```

注意事项：

（1）外部类丌能直接使用内部类的成员和方法 

（2）如果外部类和内部类具有相同的成员变量戒方法，内部类 默认访问自己的成员变量戒方法，如果要访问外部类的成员变量， 需使用this关键字

![image-20210910093412937](/image/java面向对象编程/image-20210910093412937.png)

### 在外部访问内部类

外部类 外部类对象=new 外部类();

外部类.内部类 内部类对象=外部类对象.new 内部类 ();

```java
public static void main(String [] args){ Outer out=new Outer();//创建外部类的对象 
                                        Outer.Inner inner=out.new Inner();//创建内部类的对象
                                        inner.print();//访问内部类的方法 
}
```

如果主方法在外部类内部，则可以省略Outer Inner inner=out.new Inner();

### 内部类--静态内部类

new 外部类类名.内部类().方法名

外部类类名.内部类 内部类对象名=new 外部类类名.内部类类名();

```java
package cn.bjsxt.demo;//声明包 
class Outer//声明类 
{

private static String info="hello World";// 声明私有属性 
  static class Inner//声明静态内部类 {

public void print(){//打印输出的方法 
    System.out.println(info);

} }

public static void main(String [] args){ new Outer. Inner().print();//调用方法
}

}
```

使用static声明的内部类不能访问非static的外部属性

### 内部类--匿名内部类

- 适合只需要使用一次的类，安卓中使用的比较多

![image-20210910093728913](/image/java面向对象编程/image-20210910093728913.png)

### 内部类—方法内部类

方法内部类是指：将内部类定义在外部类的方法 中。

 ▪ 注意事项： 

（1）方法内部类丌能在外部类的方法以外的地方使用，所以 方法内部类不能使用访问控制符和static修饰符

![image-20210910093857737](/image/java面向对象编程/image-20210910093857737.png)

### 垃圾回收机制

- 对象空间的分配：

  ​	–使用new关键字创建对象卲可 

- 对象空间的释放：

  –传统的C/C++语言，需要程序员负责回收已经分配内存。显式回收垃圾回收的缺点：

  ​	▪程序忘记及时回收，从而导致内存泄露，降低系统性能。 

  ​	▪程序错误回收程序核心类库的内存，导致系统崩溃。

–Java语言丌需要程序员直接控制内存回收，是由JRE在后台自动回收丌再使用的内 存，称为垃圾回收机制(Garbage Collection)。

​	▪可以提高编程效率。 

​	▪保护程序的完整性。 

​	▪其开销影响性能。Java虚拟机必须跟踪程序中有用的对象，确定哪些是无用的。

### 垃圾回收机制关键点

- 垃圾回收机制只回收JVM堆内存里的对象空间。 

- 对其他物理连接，比如数据库连接、输入流输出流、Socket连接无能为力 

- 现在的JVM有多种垃圾回收实现算法，表现各异。 

- 垃圾回收发生具有不可预知性，程序无法精确控制垃圾回收机制执行。 

- 可以将对象的引用变量设置为null，暗示垃圾回收机制可以回收该对象。 

- 程序员可以通过System.gc()戒者Runtime.getRuntime().gc()来通知系统进行垃圾回收，会有一些效果，但是系统是否迚行垃圾回收依然不确定。 

- 垃圾回收机制回收任何对象之前，总会先调用它的finalize方法（如果覆盖该方法，让一个新的引用变量重新引用该对象，则会重新激活对象）。 

- 永进不要主动调用某个对象的finalize方法，应该交给垃圾回收机制调用。